import path from 'path'

import { log, logArray, logError, logErrorSubHeader, logWarningSubHeader } from '../logger.js'
import { THEME } from '../theme.js'

const logBundleResultFunctions = ({ functions, headerMessage, logs, error }) => {
  const functionNames = functions.map(({ path: functionPath }) => path.basename(functionPath))

  if (error) {
    logErrorSubHeader(logs, headerMessage)
  } else {
    logWarningSubHeader(logs, headerMessage)
  }

  logArray(logs, functionNames)
}

/**
 * Logs the result of bundling functions
 *
 * @param {object} options
 * @param {any} options.logs
 * @param {import("@netlify/zip-it-and-ship-it").FunctionResult[]} options.results
 */
export const logBundleResults = ({ logs, results = [] }) => {
  const resultsWithErrors = results.filter(({ bundlerErrors }) => bundlerErrors && bundlerErrors.length !== 0)
  const resultsWithWarnings = results.filter(
    ({ bundler, bundlerWarnings }) => bundler === 'esbuild' && bundlerWarnings && bundlerWarnings.length !== 0,
  )
  const modulesWithDynamicImports = [
    ...new Set(results.flatMap((result) => result.nodeModulesWithDynamicImports || [])),
  ]

  if (resultsWithErrors.length !== 0) {
    logBundleResultFunctions({
      functions: resultsWithErrors,
      headerMessage: 'Failed to bundle functions with selected bundler (fallback used):',
      logs,
      error: true,
    })
  }

  if (resultsWithWarnings.length !== 0) {
    logBundleResultFunctions({
      functions: resultsWithWarnings,
      headerMessage: 'Functions bundled with warnings:',
      logs,
      error: false,
    })
  }

  if (modulesWithDynamicImports.length !== 0) {
    logModulesWithDynamicImports({ logs, modulesWithDynamicImports })
  }
}

export const logFunctionsNonExistingDir = function (logs, relativeFunctionsSrc) {
  log(logs, `The Netlify Functions setting targets a non-existing directory: ${relativeFunctionsSrc}`)
}

// Print the list of Netlify Functions about to be bundled
export const logFunctionsToBundle = function ({
  logs,
  userFunctions,
  userFunctionsSrc,
  userFunctionsSrcExists,
  internalFunctions,
  internalFunctionsSrc,
  frameworkFunctions,
  generatedFunctions,
  type = 'Functions',
}) {
  let needsSpace = false

  for (const id in generatedFunctions) {
    if (generatedFunctions[id].length === 0) {
      continue
    }

    // Getting the generator block from the first function, since it will be
    // the same for all of them.
    const { generator } = generatedFunctions[id][0]
    const functionNames = generatedFunctions[id].map((func) => path.basename(func.path))

    if (needsSpace) log(logs, '')

    log(logs, `Packaging ${type} generated by ${THEME.highlightWords(generator.displayName)} ${generator.type}:`)
    logArray(logs, functionNames, { indent: false })

    needsSpace = true
  }

  if (internalFunctions.length !== 0) {
    if (needsSpace) log(logs, '')

    log(logs, `Packaging ${type} from ${THEME.highlightWords(internalFunctionsSrc)} directory:`)
    logArray(logs, internalFunctions, { indent: false })

    needsSpace = true
  }

  if (frameworkFunctions.length !== 0) {
    if (needsSpace) log(logs, '')

    log(logs, `Packaging ${type} generated by your framework:`)
    logArray(logs, frameworkFunctions, { indent: false })

    needsSpace = true
  }

  if (!userFunctionsSrcExists) {
    return
  }

  if (userFunctions.length === 0) {
    log(logs, `No ${type} were found in ${THEME.highlightWords(userFunctionsSrc)} directory`)

    return
  }

  if (needsSpace) log(logs, '')

  log(logs, `Packaging ${type} from ${THEME.highlightWords(userFunctionsSrc)} directory:`)
  logArray(logs, userFunctions, { indent: false })
}

const logModulesWithDynamicImports = ({ logs, modulesWithDynamicImports }) => {
  const externalNodeModules = modulesWithDynamicImports.map((moduleName) => `"${moduleName}"`).join(', ')

  logWarningSubHeader(logs, `The following Node.js modules use dynamic expressions to include files:`)
  logArray(logs, modulesWithDynamicImports)
  log(
    logs,
    `\n  Because files included with dynamic expressions aren't bundled with your serverless functions by default,
  this may result in an error when invoking a function. To resolve this error, you can mark these Node.js
  modules as external in the [functions] section of your \`netlify.toml\` configuration file:

  [functions]
    external_node_modules = [${externalNodeModules}]

  Visit https://ntl.fyi/dynamic-imports for more information.
  `,
  )
}

export const logSecretsScanSkipMessage = function (logs, msg) {
  log(logs, msg, { color: THEME.warningHighlightWords })
}

export const logSecretsScanSuccessMessage = function (logs, msg) {
  log(logs, msg, { color: THEME.highlightWords })
}

export const logSecretsScanFailBuildMessage = function ({
  logs,
  scanResults,
  groupedResults,
  enhancedScanShouldRunInActiveMode,
}) {
  const { secretMatches, enhancedSecretMatches } = groupedResults
  const secretMatchesKeys = Object.keys(secretMatches)
  const enhancedSecretMatchesKeys = Object.keys(enhancedSecretMatches)

  logErrorSubHeader(
    logs,
    `Scanning complete. ${scanResults.scannedFilesCount} file(s) scanned. Secrets scanning found ${secretMatchesKeys.length} instance(s) of secrets${enhancedSecretMatchesKeys.length > 0 && enhancedScanShouldRunInActiveMode ? ` and ${enhancedSecretMatchesKeys.length} instance(s) of likely secrets` : ''} in build output or repo code.\n`,
  )

  // Explicit secret matches
  secretMatchesKeys.forEach((key) => {
    logError(logs, `Secret env var "${key}"'s value detected:`)

    secretMatches[key]
      .sort((a, b) => {
        return a.file > b.file ? 0 : 1
      })
      .forEach(({ lineNumber, file }) => {
        logError(logs, `found value at line ${lineNumber} in ${file}`, { indent: true })
      })
  })

  if (secretMatchesKeys.length) {
    logError(
      logs,
      `\nTo prevent exposing secrets, the build will fail until these secret values are not found in build output or repo files.`,
    )
    logError(
      logs,
      `\nIf these are expected, use SECRETS_SCAN_OMIT_PATHS, SECRETS_SCAN_OMIT_KEYS, or SECRETS_SCAN_ENABLED to prevent detecting.`,
    )
  }

  if (enhancedScanShouldRunInActiveMode) {
    // Likely secret matches from enhanced scan
    enhancedSecretMatchesKeys.forEach((key, index) => {
      logError(logs, `${index === 0 && secretMatchesKeys.length ? '\n' : ''}"${key}***" detected as a likely secret:`)

      enhancedSecretMatches[key]
        .sort((a, b) => {
          return a.file > b.file ? 0 : 1
        })
        .forEach(({ lineNumber, file }) => {
          logError(logs, `found value at line ${lineNumber} in ${file}`, { indent: true })
        })
    })

    if (enhancedSecretMatchesKeys.length) {
      logError(
        logs,
        `\nTo prevent exposing secrets, the build will fail until these likely secret values are not found in build output or repo files.`,
      )
      logError(
        logs,
        `\nIf these are expected, use SECRETS_SCAN_SMART_DETECTION_OMIT_VALUES, or SECRETS_SCAN_SMART_DETECTION_ENABLED to prevent detecting.`,
      )
    }
  }

  logError(
    logs,
    `\nFor more information on secrets scanning, see the Netlify Docs: https://ntl.fyi/configure-secrets-scanning`,
  )
}
